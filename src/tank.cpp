/***************************************************************************
 *   Copyright (C) 2005 by Jeff Ferr                                       *
 *   root@sat                                                              *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330x00, Boston, MA  02111-1307, USA.          *
 ***************************************************************************/
#include "atari.h"

#define ROWS 18
#define COLS 30

#define BLOCK_ROW_SIZE 8
#define BLOCK_COL_SIZE 5

uint8_t map[ROWS][COLS] = {
  0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0b,
  0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b
};

struct sprite_t {
  jgui::jsize_t<int> size;
  uint8_t data[];
} tank = {
    .size = {
      7, 9
    },
    .data = {
      0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x02,
      0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x02,
      0x02, 0x0f, 0x0f, 0x0f, 0x02, 0x02, 0x02,
      0x02, 0x0f, 0x0f, 0x0f, 0x0f, 0x02, 0x02,
      0x02, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
      0x02, 0x0f, 0x0f, 0x0f, 0x0f, 0x02, 0x02,
      0x02, 0x0f, 0x0f, 0x0f, 0x02, 0x02, 0x02,
      0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x02,
      0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x02
    },
  };

struct player_t {
  jgui::jpoint_t<float> pos;
  float angle;
  int score;
  int health;
};

class Tank : public Atari {

  private:
    player_t 
      _player0 {
        .pos = {
          16, 71
        },
        .angle = 0,
        .score = 0,
        .health = 100
      },
      _player1 {
        .pos = {
          128, 71
        },
        .angle = M_PI,
        .score = 0,
        .health = 100
      };
    jgui::jinsets_t<int>
      _offset {
        .left = 5, 
        .top = 32,
        .right = 5,
        .bottom = 12
      };

  public:
    Tank():
      Atari()
    {
    }

    virtual ~Tank()
    {
    }

    virtual void loop(int64_t timestamp)
    {
      jgui::jsize_t<int>
        canvas {SW - 2*_offset.left, SH - _offset.top - _offset.bottom};

      // input events
      if (key(KEY_UP) or key(KEY_DOWN)) {
        jgui::jpoint_t<float>
          step {
            cosf(_player0.angle), -sinf(_player0.angle)
          },
          pos = _player0.pos;

        if (key(KEY_UP)) {
          pos = pos + step;
        } else {
          pos = pos - step;
        }

        int 
          px = pos.x/BLOCK_COL_SIZE,
          py = pos.y/BLOCK_ROW_SIZE;
        bool
          flag = false;

        for (int j=-1; j<2; j++) {
          for (int i=-1; i<2; i++) {
            int
              bx = (px + i)*BLOCK_COL_SIZE,
              by = (py + j)*BLOCK_ROW_SIZE;

            if (map[py + j][px + i] != 0x02 and collide({pos.x, pos.y, BLOCK_COL_SIZE, BLOCK_ROW_SIZE}, {bx, by, BLOCK_COL_SIZE, BLOCK_ROW_SIZE}) == true) {
              flag = true;

              break;
            }
          }
        }

        if (flag == false) {
          _player0.pos = pos;
        }
      }

      if (key(KEY_LEFT)) {
        _player0.angle = _player0.angle + 0.1f;
      } else if (key(KEY_RIGHT)) {
        _player0.angle = _player0.angle - 0.1f;
      }

      if (key(KEY_ACTION)) {
        // fire
      }
		}

		virtual void draw(context &ctx)
		{
			// INFO:: draw background
			ctx.color(0x02);
			ctx.fill(true);
			ctx.rect({0, 0, SW, SH});
		  
      // INFO:: draw players
			ctx.color(0x01);
      ctx.sprite(tank.data, {_player0.pos + jgui::jpoint_t<int>{_offset.left - tank.size.width/2, _offset.top - tank.size.height/2}, tank.size}, _player0.angle);
			ctx.color(0x04);
      ctx.sprite(tank.data, {_player1.pos + jgui::jpoint_t<int>{_offset.left - tank.size.width/2, _offset.top - tank.size.height/2}, tank.size}, _player1.angle);

      // INFO:: draw map
      for (int j=0; j<ROWS; j++) {
        for (int i=0; i<COLS; i++) {
          int color = map[j][i];

          if (color != 0x02) {
			      ctx.color(map[j][i]);
			      ctx.rect({i*BLOCK_COL_SIZE + _offset.left, j*BLOCK_ROW_SIZE + _offset.top, BLOCK_COL_SIZE, BLOCK_ROW_SIZE});
          }
        }
      }
    }

};


int main(int argc, char **argv)
{
	jgui::Application::Init(argc, argv);

	Tank app;

	jgui::Application::Loop();

	return 0;
}
